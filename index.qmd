---
title: "Monte Carlo Simulation"
author: "Thomas Spoehr"
format: html
---


(Adapted from Monte Carlo Simulation: An Introduction for Engineers and Scientists by Alan Stevens, Chapter 11)

Polymers are large molecules comprised of a large number of repeated units (monomers) linked end to end. 
There are naturally occurring polymers, such as cellulose, and artificial polymers, such as polythene (polyethylene). 
A simple model of a polymer assumes its linked units are each oriented completely randomly with respect to each other. 
This results in a nearly infinite number of configurations.

Suppose the goal is to estimate the straight-line distance between the start and end of the polymer chain. 
The theoretical probability density function for this distance is $$P(R) = 4\pi R^2\left(\frac{3}{2\pi\langle r^2\rangle}\right)^{3/2}\exp\left(-\frac{3R^2}{2\langle r^2\rangle}\right), $$
where $R$ is the end-to-end distance, and the mean square position of the units is $\langle r^2\rangle = N u^2$ where $N$ is the number of units in the chain and $u$ is ithe length of each unit. 
For simplicity, we'll work with $u=1$. 


# Unconstrained Polymer Chains

The position of each link of the chain relative to the previous link can be described with angles $\theta\in[0,2\pi]$ and $\phi\in[0,pi]$ (think of $\theta$ as describing the direction in the XY plane and $\phi$ as describing the direction in the plane uniquely defined by the points $(0,0,0)$, $(x, y, 0)$, and $(x, y, z)$). In this case, $\phi$ need only cover $\pi$ radians. 

Without loss of generality, we can assume that the chain starts at the origin. 
Then, the end point in the chain can be described by a cumulative sum of a series of x, y, and z coordinates that are a function of $\theta_{n\times 1}$ and $\phi_{n\times 1}$:

$$\begin{array}{rcl} x &=& \cos(\theta)\sin(\phi)\\
y &=& \sin(\theta)\sin(\phi)\\
z &=& \cos(\phi)\end{array} $$

The distance between the origin and the end of the chain $(x,y,z)$ can be calculated as $\sqrt{x^2 + y^2 + z^2}$. 


## Single Unconstrained Link Function

Write a function that takes $n$ and returns the distance between the start and end points of a chain. 
Use vector-based operations to increase the efficiency of your function.

```{r}

set.seed(12345)

#Distance from beginning link to next link

dist.func <- function(n){
  theta <- runif(n, min = 0, max = 2*pi)
  phi <- runif(n, min = 0, max = pi)
  x <- cos(theta) * sin(phi)
  y <- sin(theta) * sin(phi)
  z <- cos(phi)
  x.sum <- sum(x)
  y.sum <- sum(y)
  z.sum <- sum(z)
  total_length <- sqrt(x.sum^2 + y.sum^2 + z.sum^2)
  return(total_length)
}


dist.func(10)


```



## Distribution of Unconstrained Links

Simulate 10000 chains and save the distribution of the end-to-end distance.

```{r}
set.seed(12345)

library(ggplot2)

length.vec <- c()

for(i in 1:10000){
  temp.length <- dist.func(10)
  length.vec <- c(length.vec, temp.length)
}

df.1 <- data.frame(1:10000, length.vec)

plot1 <- ggplot(df.1, aes(x = length.vec)) +
  geom_histogram(binwidth = 0.1) +
    labs(title = "Distribtution of Length of Polymer Chains",
         subtitle = "Each chain of length 10",
         x = "Length of Chain",
         y = "Frequency") +
        theme_minimal()

plot1

```


# Constrained Polymer Chains
For real polymers, adjacent links don’t have the complete freedom of orientation allowed in the case of the ideal model. 
We can simulate a simple constrained orientation model by restricting the relative orientation of adjacent links.
We’ll prevent adjacent links from orienting themselves such that there is an acute angle smaller than, say 45° between them. 
We can do this by checking the angle between adjacent links after choosing a random orientation and repeatedly choosing the random orientation until that angle is larger than 45°.


## Single Constrained Link Function

Write a function that takes $n$ and returns the distance between the start and end points of a chain. 
Can you think of a way to use vectorized functions to accomplish this task? Why or why not? 

I think that given the skills we have learned in class I don't know that there is a way to accomplish this without using loops. I wrote the function below using a while loop and if statement where I'm not sure how you would check the conditions without using the checks that only the while loop can provide. I don't think that we can just do an apply here and it might be difficult to utlize a vector function to substutute in a if statement given the way I have written the program.

```{r}

# We know that the distance between the starting point of the original polymer and second polymer has to be greater than approximately 0.7654 through trigonometry functions

#Note that c1 and c2 must be vectors of coordinates (x,y,z)

# Scratch Work to get to answer
dist.calc <- function(c1, c2){
  dist <- sqrt((c1[1]+c2[1])^2 + (c1[2]+c2[2])^2 + (c1[3]+c2[3])^2)
  return(dist)
}

# n = 10
# chain_count = 0
# total.dist = c()
# init_coord <- c(0,0,0)
# 
# while(chain_count < n){
#   theta <- runif(1, min = 0, max = 2*pi)
#   phi <- runif(1, min = 0, max = pi)
#   x <- cos(theta) * sin(phi)
#   y <- sin(theta) * sin(phi)
#   z <- cos(phi)
#   considered_vec <- c(x, y, z)
#   dist <- dist.calc(init_coord, considered_vec)
#   if(dist >= 0.7654){
#     total.dist <- c(total.dist, dist)
#     init_coord <- considered_vec
#     chain_count = chain_count + 1 
#    }
# }


#### Final function

constrained.polymer.chain.distance <- function(n){
  chain_count = 0
  total.dist = c()
  init_coord <- c(0,0,0)
  while(chain_count < n){
  theta <- runif(1, min = 0, max = 2*pi)
  phi <- runif(1, min = 0, max = pi)
  x <- cos(theta) * sin(phi)
  y <- sin(theta) * sin(phi)
  z <- cos(phi)
  considered_vec <- c(x, y, z)
  dist <- dist.calc(init_coord, considered_vec)
  if(dist >= 0.7654){
    total.dist <- c(total.dist, dist)
    init_coord <- considered_vec
    chain_count = chain_count + 1 
      }
    }
  total_distance <- sum(total.dist)
  return(total_distance)
}


constrained.polymer.chain.distance(10)

```


## Distribution of Constrained Links

Simulate 10000 chains and save the distribution of the end-to-end distance.
Plot the density of the unconstrained links and the density of constrained links on the same plot -- how much has the distribution changed? 

We can see the distribution has shifted drastically to have a mean centered around 14 as opposed 2.5. The distribution of the constrained polymer chain also appears to be more symmetric than the unconstrained polymer chain which is skewed right.
```{r}
set.seed(12345)

library(ggplot2)

constrained.length.vec <- c()

for(i in 1:10000){
  temp.length.constr <- constrained.polymer.chain.distance(10)
  constrained.length.vec <- c(constrained.length.vec, temp.length.constr)
}

df.2 <- data.frame(c(1:10000), constrained.length.vec)

plot2 <- ggplot(df.2, aes(x = constrained.length.vec)) +
  geom_histogram(binwidth = 0.1) +
    labs(title = "Distribtution of Length of Constrained Polymer Chains",
         subtitle = "Each chain of length 10",
         x = "Length of Chain",
         y = "Frequency") +
        theme_minimal()

plot2

```


Comparison of the two plots.

```{r}
plot1
plot2



```

